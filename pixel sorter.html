<!doctype html>
<html lang="en-US">
    <head>
		<title>Natski</title>
        <meta charset="UTF-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
        <meta name="theme-color" content="#1e1e1e"/>
        <meta name="description" content="ground up website for fun"/>
        <meta name="keywords" content="portfolio, natspooky, natski"/>
        <meta name="author" content="NATSKI"/>
        <meta name="copyright" content="NATSKI">
        <meta name="color-scheme" content="normal">
		<link rel="icon" type="image/svg+xml" href="icon/svg/favicon.svg"/>
        <link rel="apple-touch-icon"sizes="57x57" href="icon/mobile/57.png"/>
        <link rel="apple-touch-icon"sizes="60x60" href="icon/mobile/60.png"/>
        <link rel="apple-touch-icon"sizes="72x72" href="icon/mobile/72.png"/>
        <link rel="apple-touch-icon"sizes="76x76" href="icon/mobile/76.png"/>
        <link rel="apple-touch-icon"sizes="114x114" href="icon/mobile/114.png"/>
        <link rel="apple-touch-icon"sizes="120x120" href="icon/mobile/120.png"/>
        <link rel="apple-touch-icon"sizes="144x144" href="icon/mobile/144.png"/>
        <link rel="apple-touch-icon"sizes="152x152" href="icon/mobile/152.png"/>
        <meta property="og:title" content="Natspooky"/>
        <meta property="og:description" content="ground up website for fun"/>
        <meta property="og:image" content="https://natski.netlify.com/icon/avatar/400.png"/>
        <meta property="og:image:width" content="400"/>
        <meta property="og:image:height" content="400"/>
        <meta property="og:url" content="https://natski.netlify.com"/>
        <meta property="og:locale" content="en_US"/>
        <meta property="og:type" content="website"/>
        <meta property="og:site_name" content="NATSKI"/>
        <meta name="twitter:title" content="Natspooky">
        <meta name="twitter:description" content="ground up website for fun">
        <meta name="twitter:image" content="https://natski.netlify.com/icon/avatar/400.png">
        <meta name="twitter:site" content="@natspooky_">
        <meta name="twitter:creator" content="@natspooky_">
        <meta name="twitter:card" content="summary">
        <link rel="stylesheet" type="text/css" href="lib/css/main.css"/>
        <link rel="stylesheet" type="text/css" href="lib/css/animations.css"/>
        <link rel="stylesheet" type="text/css" media="screen and (orientation: portrait)" href="lib/css/scale.css"/>
        <link rel="prefetch" href="icon/img/kuru.gif">
        <link rel="prefetch" href="icon/img/ki.gif">
        <link rel="prefetch" href="icon/img/nahida.gif">
        <link rel="prefetch" href="icon/img/traveler.gif">
        <link rel="prefetch" href="icon/audio/kuru.mp3">
        <link rel="prefetch" href="icon/audio/kuruine.mp3">
	</head>
    <body>

        
        <div id="colourpanelback"></div>
        <header>
            <div class="observe"></div>
            <div class="imagebox">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 850.89 850.9">
                    <path fill="var(--bar)" d="M757.63.5H92.77C41.58.5.08,41.99.08,93.18v665.02c0,51.19,41.5,92.69,92.69,92.69h664.86c51.19,0,92.68-41.5,92.68-92.69V93.18c0-51.19-41.49-92.68-92.68-92.68ZM383.3,727.2c0,22.08-17.9,39.97-39.98,39.97H123.69c-22.08,0-39.98-17.89-39.98-39.97v-65.37h89.03c17.62,0,31.9-14.29,31.9-31.9v-19.84c0-17.61-14.28-31.89-31.9-31.89h-89.03v-305h89.03c17.62,0,31.9-14.28,31.9-31.9v-19.83c0-17.62-14.28-31.9-31.9-31.9h-89.03v-65.38c0-22.08,17.9-39.98,39.98-39.98h219.63c22.08,0,39.98,17.9,39.98,39.97v603.02ZM766.68,189.56h-89.19c-17.62,0-31.9,14.29-31.9,31.9v19.83c0,17.62,14.28,31.9,31.9,31.9h89.19v305h-89.19c-17.62,0-31.9,14.28-31.9,31.9v19.83c0,17.62,14.28,31.9,31.9,31.9h89.19v65.38c0,22.08-17.9,39.97-39.98,39.97h-219.63c-22.08.01-39.98-17.88-39.98-39.96V124.19c0-22.08,17.9-39.98,39.98-39.98h219.63c22.08,0,39.98,17.9,39.98,39.98v65.37Z"/>
                  </svg>
                <img src="icon/thumbnails/pixelsorter.png" alt="pixel sorter" id="headerimage" draggable="false">
            </div>
            <h2>Pixel Sorter</h2>
        </header>

        <style>
            .images {
                position: relative;
                width: 100%;
                height: auto;
                padding: 50px;
                display: flex;
                flex-wrap: wrap;
                justify-content: space-evenly;
                align-items: center;
            }
            .images canvas {
                position: relative;
                width: 40%;
                background-color: #f0f0f0;
                opacity: 0;
                transform: scale(0.7);
                transition: 0.4s;
            }
            .images canvas.active {
                opacity: 1;
                transform: scale(1);
            }
            .tools {
                position: fixed;
                width: auto;
                height: auto;
                right: 15px;
                transform: translateY(-50%);
                top: 50%;
                border-radius: 100vmax;
                padding: 10px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                background-color: #33333360;
                z-index: 100;
            }
            .tools button{
                padding: 10px;
                border-radius: 100vmax;
                background-color: #f0f0f010;
                margin: 5px 0;
            }
            .tools button GIS-icon
            {
                background-color: #f0f0f0;
                font-size: 20px;
            }
            input[type="file"] {
                display: none;
            }
            .upload {
                display: block;
                padding: 10px;
                border-radius: 100vmax;
                background-color: #f0f0f010;
                margin: 5px 0;
                cursor: pointer;
            }
            .upload GIS-icon
            {
                background-color: #f0f0f0;
                font-size: 20px;
            }
        </style>
        
        <main>
            <div class="tools">
                <!-- toolbar here -->
                <label for="inputImage" class="upload">
                    <GIS-icon title="add_new"></GIS-icon>
                </label>
                <input type="file" accept="image/*" id="inputImage" />
                <button onclick="toggleSSM()">
                    <GIS-icon title="config"></GIS-icon>
                </button>
                <button onclick="processor.processColourSpace(processor.OGimage)">
                    <GIS-icon title="play"></GIS-icon>
                </button>
                <button onclick="downloadImage()">
                    <GIS-icon title="download"></GIS-icon>
                </button>
            </div>
            <div class="images">
                <!-- image and canvas here-->
                <canvas id="in"></canvas>
                <canvas id="out"></canvas>
            </div>
        </main>

        <script>
            /*
                make faster by mergin the bitmask creation and image system

                also, make it so that repeated lines dont exist [a boarder for hte bit mask where the width starts and ends]

                compress images if they are over 1000 pixels in any dimention


                (e.naturalHeight || e.offsetHeight || e.height)

                img.onload = function () {

    // set size proportional to image
    canvas.height = canvas.width * (img.height / img.width);

    // step 1 - resize to 50%
    var oc = document.createElement('canvas'),
        octx = oc.getContext('2d');

    oc.width = img.width * 0.5;
    oc.height = img.height * 0.5;
    octx.drawImage(img, 0, 0, oc.width, oc.height);

    // step 2
    octx.drawImage(oc, 0, 0, oc.width * 0.5, oc.height * 0.5);

    // step 3, resize to final size
    ctx.drawImage(oc, 0, 0, oc.width * 0.5, oc.height * 0.5,
    0, 0, canvas.width, canvas.height);
}
img.src = "//i.imgur.com/SHo6Fub.jpg";
            */
            let processor;
            window.onload = function() {
                processor = new PixelSorter(document.getElementById('out'),document.getElementById('in'))
                console.log(document.getElementById('out'),document.getElementById('in'))
                document.getElementById('inputImage').addEventListener('change', function(event) {
                        
                        processor.createImageBuffer(this)

                })
            }

            function downloadImage() {

                // Grab the canvas element
                let canvas = document.getElementById("out");

                /* Create a PNG image of the pixels drawn on the canvas using the toDataURL method. PNG is the preferred format since it is supported by all browsers
                */
                let dataURL = canvas.toDataURL("image/png");

                // Create a dummy link text
                let a = document.createElement('a');
                // Set the link to the image so that when clicked, the image begins downloading
                a.href = dataURL
                // Specify the image filename
                a.download = 'Sorted Image.jpeg';
                // Click on the link to set off download
                a.click();
            }

            class PixelSorter {
                constructor(canvas, imageCanvas) {
                    this.lowBound = 0
                    this.upBound = 255
                    this.matchColour = [0,0,0]
                    this.matchColourThresh = 100
                    this.colourSpace = 'GRAY'
                    this.HSVtype = 'Value'
                    this.outputChannel = [false,false,false,true,true,true]
                    //this.imageType
                    this.image = []
                    this.outputImage = []
                    this.colourMask = []
                    this.bitMask = []
                    this.OGimageData = []
                    this.imageCanvas = imageCanvas
                    this.imageCTX = this.imageCanvas.getContext('2d')
                    this.outputCanvas = canvas
                    //console.log(canvas, this.outputCanvas)
                    this.outputCTX = this.outputCanvas.getContext('2d')
                }

                readInput(file, image) {
                    let reader = new FileReader()
                    reader.onload = function() {
                        let dataURL = reader.result
                        //console.log(dataURL.slice(22, dataURL.length), 'image/png'.length)
                        //console.log(atob(dataURL.slice(13 + this.imageType.length, dataURL.length)))
                        image.src = dataURL
                    }
                    //this.imageType = file.files[0].type
                    reader.readAsDataURL(file.files[0]);
                }

                createImageBuffer(file) {
                    this.outputCanvas.classList.remove('active')
                    let e = new Image()

                    e.onload = () => {
    
                        let o, c;
                        c = this.outputCanvas.height = this.imageCanvas.height = e.naturalHeight || e.offsetHeight || e.height, 
                        o = this.imageCanvas.width = this.outputCanvas.width = e.naturalWidth || e.offsetWidth || e.width, 
                        this.imageCTX.drawImage(e, 0, 0)
                        this.imageCanvas.classList.add('active')
                        //console.log('working')
                        this.OGimageData = this.imageCTX.getImageData(0, 0, o, c)
                    }
                    this.readInput(file, e)                    
                }

                get OGimage() {
                    return this.OGimageData;
                }


                processColourSpace(image) {

                    switch(this.colourSpace) {

                        case 'GRAY':
                            console.log('starting RGB to Grayscale')
                            this.processToGrayScale(image).then((map) => {

                                return this.createBitMask(map)

                            }).then((bitMask) => {

                                return this.generateOutput(bitMask)

                            }).then((output) => {

                                this.drawOutput(output)
                            })

                            break;
            
                        case 'LAB':
                            console.log('starting RGB to LAB')
                            this.processToLAB(image).then((map) => {

                                return this.createBitMask(map)

                            }).then((bitMask) => {

                                return this.generateOutput(bitMask)

                            }).then((output) => {

                                this.drawOutput(output)
                            })
                            break;

                        case 'HSV':
                            console.log('starting RGB to HSV')
                            this.processToHSV(image).then((map) => {

                                return this.createBitMask(map)

                            }).then((bitMask) => {

                                return this.generateOutput(bitMask)

                            }).then((output) => {

                                this.drawOutput(output)
                            })
                            
                            break;
                    }

                }

                colorSpace(colourSpace) {
                    this.colourSpace = colourSpace
                    console.log(this.colourSpace)
                }

                HSVfilter(HSV) {
                    this.HSVtype = HSV
                    //console.log(this.colourSpace)
                }

                upperBound(upperBound) {
                    this.upBound = upperBound
                }

                lowerBound(lowerBound) {
                    this.lowBound = lowerBound
                }

                matchCol(colour) {
                    this.matchColour = colour
                }

                matchThresh(thresh) {
                    this.matchColourThresh = thresh
                }


                toggleValue(check, index) {
                    this.outputChannel[index] = !check
                    console.log(this.outputChannel)
                }

                processToLAB(image) {
                    let tempMask = []
                    this.image = this.processToRGB(image)
                    for(let i = 0; i < this.image.length; i++) {
                        let r = this.image[i][0],
                        g = this.image[i][1],
                        b = this.image[i][2],
                        deltaE = this.labDeltaE(this.convertRGBToLab(this.matchColour), this.convertRGBToLab([r,g,b]))

                        this.image[i].push(deltaE)
                        tempMask.push(deltaE)
                        //console.log(this.image[i])
                    }

                    return Promise.resolve(tempMask)
                }


                convertRGBToLab(rgb){
                    let red = rgb[0] / 255,
                    green = rgb[1] / 255,
                    blue = rgb[2] / 255,
                    x, y, z;

                    red = (red > 0.04045) ? ((red + 0.055) / 1.055) ** (2.4) : red / 12.92;
                    green = (green > 0.04045) ? ((green + 0.055) / 1.055) ** (2.4) : green / 12.92;
                    blue = (blue > 0.04045) ? ((blue + 0.055) / 1.055) ** (2.4) : blue / 12.92;

                    x = (red * 0.4124 + green * 0.3576 + blue * 0.1805) / 0.95047;
                    y = (red * 0.2126 + green * 0.7152 + blue * 0.0722) / 1.00000;
                    z = (red * 0.0193 + green * 0.1192 + blue * 0.9505) / 1.08883;

                    x = (x > 0.008856) ? x ** (1/3) : (7.787 * x) + 16/116;
                    y = (y > 0.008856) ? y ** (1/3) : (7.787 * y) + 16/116;
                    z = (z > 0.008856) ? z ** (1/3) : (7.787 * z) + 16/116;

                    return [(116 * y) - 16, 500 * (x - y), 200 * (y - z)]
                }

                labDeltaE(labOne, labTwo){
                    let deltaL = labOne[0] - labTwo[0],
                    deltaA = labOne[1] - labTwo[1],
                    deltaB = labOne[2] - labTwo[2],

                    c1 = Math.sqrt(labOne[1] * labOne[1] + labOne[2] * labOne[2]),
                    c2 = Math.sqrt(labTwo[1] * labTwo[1] + labTwo[2] * labTwo[2]),

                    deltaC = c1 - c2,
                    deltaH = deltaA * deltaA + deltaB * deltaB - deltaC * deltaC;
                    deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);

                    let sc = 1.0 + 0.045 * c1,
                    sh = 1.0 + 0.015 * c1,

                    deltaLKlsl = deltaL / (1.0),
                    deltaCkcsc = deltaC / (sc),
                    deltaHkhsh = deltaH / (sh),

                    i = deltaLKlsl * deltaLKlsl + deltaCkcsc * deltaCkcsc + deltaHkhsh * deltaHkhsh;

                    return i < 0 ? 0 : Math.sqrt(i);
                }


                createBitMask(map) {
                    this.colourMask = map
                    let tempMask = []

                    for(let i = 0; i < this.colourMask.length; i++) {
                        let bit = 0

                        if(this.colourSpace != 'LAB') {

                            if(this.colourMask[i] <= this.lowBound || this.colourMask[i] >= this.upBound) {
                                bit = ((this.outputChannel[3]) ? 1 : null)
                            }else {
                                bit = ((this.outputChannel[3]) ? null : 1)
                            }

                        }else {

                            if(this.colourMask[i] >= this.matchColourThresh) {
                                bit = ((this.outputChannel[3]) ? 1 : null)
                            }else {
                                bit = ((this.outputChannel[3]) ? null : 1)
                            }

                        }

                        if(tempMask.length < 1 || tempMask[tempMask.length - 1][tempMask[tempMask.length - 1].length - 1] != bit) { 
                            tempMask.push([bit]) 
                        }else { 
                            tempMask[tempMask.length - 1].push(bit) 
                        }

                    }

                    return Promise.resolve(tempMask)
                }

                generateOutput(bitMask) {
                    console.log('starting pixel sort')
                    this.colourMask = (this.bitMask = bitMask)

                    //console.log(bitMask)
                    
                    let maskLen = 0
                    for(let main = 0; main < this.bitMask.length; main++) {
                        for(let sub = 0; sub < this.bitMask[main].length; sub++) {
                            if(this.bitMask[main][sub]) {
                                this.colourMask[main][sub] = this.image[sub + maskLen]
                            }
                        }
                        maskLen += this.bitMask[main].length
                    }

                    let sortedImage = this.colourMask.map((bits) => {

                        if(bits[0] == null) return bits
                        return bits.sort( (a, b) => (this.outputChannel[4]) ? a[3] - b[3] : b[3] - a[3])

                    })

                    maskLen = 0
                    for(let main = 0; main < this.bitMask.length; main++) {
                        for(let sub = 0; sub < this.bitMask[main].length; sub++) {
                            if(this.bitMask[main][sub]) {
                                this.image[sub + maskLen] = sortedImage[main][sub]
                            }
                        }
                        maskLen += this.bitMask[main].length
                    }




                    //console.log(this.image)
                    return Promise.resolve(this.image)
                }

                drawOutput(output) {

                    switch(this.outputChannel[5]) {
                        case false:
                            this.outputImage = []
                            for(let main = 0; main < this.bitMask.length; main++) {
                                for(let sub = 0; sub < this.bitMask[main].length; sub++) {
                                    if(this.bitMask[main][sub]) {
                                        this.outputImage.push([0,0,0])
                                    }else {
                                        this.outputImage.push([255,255,255])
                                    }
                                }
                            }
                            break;
                        case true:
                            this.outputImage = output
                            break;
                    }
                    for(let y = 0; y < this.outputCanvas.height; y++) {
                        for(let x = 0; x < this.outputCanvas.width; x++) {  
                    
                            this.outputCTX.fillStyle = `rgb(${
                                (this.outputChannel[0]) ? 0 : this.outputImage[this.outputCanvas.width * y + x][0]} ${
                                    (this.outputChannel[1]) ? 0 : this.outputImage[this.outputCanvas.width * y + x][1]} ${
                                        (this.outputChannel[2]) ? 0 : this.outputImage[this.outputCanvas.width * y + x][2]})`;
                            this.outputCTX.fillRect(x, y, 1, 1);
                        }
                    }
                    setTimeout(() => {
                        this.outputCanvas.classList.add('active')
                    }, 100);
                }

                processToGrayScale(image) {
                    let tempMask = []
                    this.image = this.processToRGB(image)
                    for(let i = 0; i < this.image.length; i++) {
                        let r = this.image[i][0] * .3, // ------> Red is low
                        g = this.image[i][1] * .59, // ---> Green is high
                        b = this.image[i][2] * .11, // ----> Blue is very low

                        gray = r + g + b


                        this.image[i].push(gray)
                        tempMask.push(gray)
                    }

                    return Promise.resolve(tempMask)
                }

                

                processToRGB(image) {
                    let data = image.data,     
                    dataLength = data.length,
                    tempImage = []
                    //console.log(data)
                    //this.greyMask = []
                    for(let i = 0; i < dataLength; i+=4) {
                        let r = data[i],
                        g = data[i+1],
                        b = data[i+2];
                        tempImage.push([r,g,b])
                        //this.greyMask.push(this.processToGreyScale([r,g,b]))
                    }
                    return tempImage
                }


                sortMerge(array, value) {
                    if (array.length <= 1) return array //|| value >= 40) return array
                    let center = Math.floor(array.length / 2),
                    front = this.sortMerge(array.slice(0, center), value + 1),
                    back = this.sortMerge(array.slice(center), value + 1)

                    return this.merge(front, back)
                }
                merge(left, right) {
                    let sortedArray = []
                    while(left.length && right.length) {

                        if(left[0][3] < right[0][3]) {
                            sortedArray.push(left.shift())
                        }else {
                            sortedArray.push(right.shift())
                        }
                    }
                    return [...sortedArray, ...left, ...right]
                }

                sortBubble(array){
                    let len = array.length,
                    sortedArray = array;
                    for(let i = 0; i < len; i++) {
                        for(let x = 0; x < len - 1; x++){
                            if(sortedArray[x][3] > sortedArray[x + 1][3]) {
                                let tempStorage = sortedArray[x];
                                sortedArray[x] = sortedArray[x + 1]
                                sortedArray[x + 1] = tempStorage
                            }
                        }
                    }
                    return sortedArray
                }


                quickSort(arr) {
                    if (arr.length <= 1) {
                        return arr;
                    }

                    let pivot = arr[0][3];
                    let leftArr = [];
                    let rightArr = [];

                    for (let i = 1; i < arr.length; i++) {
                        if (arr[i][3] < pivot) {
                        leftArr.push(arr[i]);
                        } else {
                        rightArr.push(arr[i]);
                        }
                    }

                    return [...this.quickSort(leftArr), arr[0], ...this.quickSort(rightArr)];
                }


                processToHSV(image) {
                    let tempMask = []
                    this.image = this.processToRGB(image)
                    for(let i = 0; i < this.image.length; i++) {
                        let rabs, gabs, babs, rr, gg, bb, h, s, v, diff, diffc, percentRoundFn;
                        rabs = this.image[i][0] / 255;
                        gabs = this.image[i][1] / 255; 
                        babs = this.image[i][2] / 255;
                        v = Math.max(rabs, gabs, babs),
                        diff = v - Math.min(rabs, gabs, babs);
                        diffc = c => (v - c) / 6 / diff + 1 / 2;
                        percentRoundFn = num => Math.round(num * 100) / 100;
                        if (diff == 0) {
                            h = s = 0;
                        } else {
                            s = diff / v;
                            rr = diffc(rabs);
                            gg = diffc(gabs);
                            bb = diffc(babs);

                            if (rabs === v) {
                                h = bb - gg;
                            } else if (gabs === v) {
                                h = (1 / 3) + rr - bb;
                            } else if (babs === v) {
                                h = (2 / 3) + gg - rr;
                            }
                            if (h < 0) {
                                h += 1;
                            }else if (h > 1) {
                                h -= 1;
                            }
                        }
                        switch(this.HSVtype) {
                            case 'Hue':
                                this.image[i].push((Math.round(h * 360) / 179) * 255)
                                tempMask.push((Math.round(h * 360) / 179) * 255)
                                break;
                            case 'Saturation':
                                this.image[i].push(percentRoundFn(s * 100))
                                tempMask.push(percentRoundFn(s * 100))
                                break;
                            case 'Value':
                                this.image[i].push(percentRoundFn(v * 100))
                                tempMask.push(percentRoundFn(v * 100))
                                break
                        }
                        
                    }
                    //console.log(percentRoundFn(v * 100))
                    return Promise.resolve(tempMask)//[Math.round(h * 360),percentRoundFn(s * 100),percentRoundFn(v * 100)]  
                    }


                    hexToRgb(hex) {
                        let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                        return result ? [
                            parseInt(result[1], 16),
                            parseInt(result[2], 16),
                            parseInt(result[3], 16)
                        ] : null;
                    }
                }
            

        </script>

        <footer>
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 850.35 850.35">
                    <path d="M850.35,48.04V802.31c0,26.53-21.51,48.04-48.04,48.04h-171.87c-18.33,0-35.64-8.4-46.98-22.8l-243.52-309.3c-29.93-38.02-91.02-16.85-91.02,31.53v252.55c0,26.52-21.5,48.02-48.02,48.02H48.02c-26.52,0-48.02-21.5-48.02-48.02V48.02C0,21.5,21.5,0,48.02,0H219.9c18.33,0,35.64,8.4,46.99,22.8l243.46,309.07c29.96,38.03,91.08,16.85,91.08-31.56V48.04c0-26.53,21.51-48.04,48.04-48.04h152.85c26.53,0,48.04,21.51,48.04,48.04Z"/>
                </svg>
                <p>©NATSKI<br>ENCORE</p>
            </div>
            <span></span>
            <a onclick="parent.loadframe('Privacy Policy');parent.backPage(1)">Privacy Policy</a>
        </footer>

        <div id="SSM" style="display: none;">
            <section>
                <h1><GIS-icon title="gear"></GIS-icon>Sort Settings</h1>
            </section>
        
            <section class="SSMsearch">
                <h1><GIS-icon title="magnify"></GIS-icon>Search</h1>
                <span class="SSMcategory">
                    <input class="SSMinput" type="text" ssminfo="Lets you search for a specific setting" placeholder="Search">
                </span>
            </section>

            <section>
                <h1><GIS-icon title="bookshelf"></GIS-icon>Output</h1>
                <span class="SSMcategory SSMcheckbox">
                    <p>Red Channel</p>
                    <input type="checkbox" checked class="SSMinput" ssminfo="toggles the red channel" onclick="processor.toggleValue(this.checked, 0)">
                </span>
                <span class="SSMcategory SSMcheckbox">
                    <p>Green Channel</p>
                    <input type="checkbox" checked class="SSMinput" ssminfo="toggles the green channel" onclick="processor.toggleValue(this.checked, 1)">
                </span>
                <span class="SSMcategory SSMcheckbox">
                    <p>Blue Channel</p>
                    <input type="checkbox" checked class="SSMinput" ssminfo="toggles the blue channel" onclick="processor.toggleValue(this.checked, 2)">
                </span>

                <span class="SSMcategory SSMcheckbox">
                    <p>Inverse Mask</p>
                    <input type="checkbox" class="SSMinput" ssminfo="toggles the red channel" onclick="processor.toggleValue(this.checked, 3)">
                </span>

                <span class="SSMcategory SSMcheckbox">
                    <p>Reverse Sort</p>
                    <input type="checkbox" class="SSMinput" ssminfo="toggles the red channel" onclick="processor.toggleValue(this.checked, 4)">
                </span>

                <span class="SSMcategory SSMcheckbox">
                    <p>Display BitMap</p>
                    <input type="checkbox" class="SSMinput" ssminfo="displayed the bitMap used to filter the image" onclick="processor.toggleValue(this.checked, 5)">
                </span>
                
            </section>

            <section>
                <h1><GIS-icon title="apps"></GIS-icon>Sorting</h1>
                <span class="SSMcategory">
                    <p>Sorting Type</p>
                    <div class="SSMselection SSMinput" ssminfo="changes which method you want to use to sort the pixels">
                        <div class="itemContainer">
                            <span class="SSMheader">
                                Grayscale Sorting
                            </span>
                            <span class="SSMitem" value="GRAY" onclick="processor.colorSpace('GRAY')">
                                Grayscale Sorting
                            </span>
                            <span class="SSMitem" value="GRAY" onclick="processor.colorSpace('HSV')">
                                HSV Sorting
                            </span>
                            <span class="SSMitem" value="LAB" onclick="processor.colorSpace('LAB')">
                                LAB sorting
                            </span>
                            
                        </div>
                    </div>
                </span>
            </section>
            
        
            <section>
                <h1><GIS-icon title="config"></GIS-icon>Threshold</h1>
                <span class="SSMcategory">
                    <p>Lower Bound</p>
                    <input type="range" class="SSMinput" min="0" max="255" value="20" step="1" ssminfo="changes the lower bound used to sort the pixels" onchange="processor.lowerBound(this.value)">
                </span>
                <span class="SSMcategory">
                    <p>Upper Bound</p>
                    <input type="range" class="SSMinput" min="0" max="255" value="150" step="1" ssminfo="changes the upper bound used to sort the pixels" onchange="processor.upperBound(this.value)">
                </span>
                <span class="SSMcategory">
                    <p>HSV Threshold Type</p>
                    <div class="SSMselection SSMinput" ssminfo="changes which HSV property will be sorted when sorting by HSV">
                        <div class="itemContainer">
                            <span class="SSMheader">
                                Value
                            </span>
                            <span class="SSMitem" value="Hue" onclick="processor.HSVfilter('Hue')">
                                Hue
                            </span>
                            <span class="SSMitem" value="Saturation" onclick="processor.HSVfilter('Saturation')">
                                Saturation
                            </span>
                            <span class="SSMitem" value="Value" onclick="processor.HSVfilter('Value')">
                                Value
                            </span>
                            
                        </div>
                    </div>
                </span>
                <span class="SSMcategory SSMcolour">
                    <p>LAB Colour Match</p>
                    <input type="color" class="SSMinput" ssminfo="changes the colour that will be matched to the pixels when sorting" onchange="processor.matchCol(processor.hexToRgb(this.value))">
                </span>
                <span class="SSMcategory">
                    <p>LAB Colour Threshold</p>
                    <input type="range" class="SSMinput" min="0" max="100" value="100" step="1" ssminfo="changes the threshold used to sort the pixels when using a LAB sort" onchange="processor.matchThresh(this.value)">
                </span>
            </section>
        </div>

        <noscript>
            <h1>javascript is disabled</h1>
            <p>ENCORE.js requires javascript in order to run, please enable javascript</p>
        </noscript>
        <script src="lib/js/ENCORE_NAT.js"></script>
        <script src="lib/js/ENCORE_GIS.js"></script>
        <script>
            GIS_settings = {'style':1}
        </script>
        <script src="lib/js/ENCORE_SSM.js"></script>
        <script>
            SSM_settings = {'style':1}
        </script>
        <script src="lib/js/ENCORE_APF.js"></script>
    </body>
</html>